
/*
 * Copyright © 2002 Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * California 95054, U.S.A. All rights reserved.  Sun Microsystems, Inc. has
 * intellectual property rights relating to technology embodied in the product
 * that is described in this document. In particular, and without limitation,
 * these intellectual property rights may include one or more of the U.S.
 * patents listed at http://www.sun.com/patents and one or more additional
 * patents or pending patent applications in the U.S. and in other countries.
 * U.S. Government Rights - Commercial software. Government users are subject
 * to the Sun Microsystems, Inc. standard license agreement and applicable
 * provisions of the FAR and its supplements.  Use is subject to license terms.
 * Sun,  Sun Microsystems,  the Sun logo and  Java are trademarks or registered
 * trademarks of Sun Microsystems, Inc. in the U.S. and other countries.  This
 * product is covered and controlled by U.S. Export Control laws and may be
 * subject to the export or import laws in other countries.  Nuclear, missile,
 * chemical biological weapons or nuclear maritime end uses or end users,
 * whether direct or indirect, are strictly prohibited.  Export or reexport
 * to countries subject to U.S. embargo or to entities identified on U.S.
 * export exclusion lists, including, but not limited to, the denied persons
 * and specially designated nationals lists is strictly prohibited.
 */


options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(parserEtiqueta)

package Analizadores.Calcular;
import AST.Nodo;
import java.io.ByteArrayInputStream;
import java.io.InputStream;

public class parserEtiqueta 
{    
    public String cadenaAuxiliar="";
    public static Nodo main(String args[]) throws ParseException
    {
        if(args.length>0)
        {

            InputStream data = new ByteArrayInputStream(args[0].getBytes());
            parserEtiqueta analizador = new parserEtiqueta(data);
            return analizador.Etiqueta();   
        }
        else
        {
            try
            {
                parserEtiqueta analizador = new parserEtiqueta(System.in);
                analizador.Etiqueta();
            }
            catch (ParseException e)
            {
                System.out.println(e.getMessage());
                System.out.println("Errores------------------");
            }              
        }
        return null;
    }

    void errorPanico(int tokenSinc) 
    { 
        ParseException e = generateParseException();     
        Token t; 
        do 
        {
            t = getNextToken();
        } 
        while (t.kind != tokenSinc);
    }

    public void imprimir(String mensaje)
    {
        System.out.println(mensaje);
    }   

}
PARSER_END(parserEtiqueta)


/*
<ESTADO> -- ESTADO es el nombre del estado en el que vamos a declarar las reglas léxicas.
SKIP: ignora el no terminal
MORE: encicla en una producción 
TOKEN: tokens
TOKEN_ESPCIAL: saber
*/


SPECIAL_TOKEN:
{
    <ESPACIO:(" " | "\t" | "\n" | "\r" )+>
}


TOKEN :
{

<numeral : "#">
|<corchA : "[" >
|<corchC : "]" >
|<punto: ".">
|<doblepunto: "..">
|<Cualquiera : (~["#",".", "[", "]"])+ >
|<ID: (["a"-"z","A"-"Z"]("_")?)(["a"-"z","A"-"Z"]|["0"- "9"]|"_")*>
|<funcion_vacia:<ID><ESPACIO>":"<ESPACIO>"("<ESPACIO>")">
}


Nodo Etiqueta() :
{
    Nodo Cad;
    Nodo nuevo;
    Token t= null;

}
{
(Cad = ETQ())+ <EOF> 
{
    imprimir("Cad->"+Cad);
    nuevo = Cad;
    return nuevo;
}
}


Nodo ETQ() :
{
    String Cad;
    String aux;
    Nodo nuevo = null;
    Nodo derecha = null;
    Nodo izquierda = null;
}
{
    derecha = T() izquierda = ETQ2() 
    {
        //Cad = Cad + aux;  //return Cad;
        nuevo = new Nodo("etiqueta",0,0);
        nuevo.add(derecha);
        nuevo.add(izquierda);
        return nuevo;
    }
    
}


Nodo ETQ2() :
{
    String Cad;
    String aux;
    Nodo izquierdo = null;
    Nodo derecho = null;
    Nodo nuevo  = null;
}
{
        izquierdo = T()  derecho= ETQ2() 
        {
            //Cad = Cad + aux; // return Cad;
            nuevo = new Nodo("etiqueta",0,0);
            nuevo.setValue(derecho.getValue()+izquierdo.getValue());
            //nuevo.add(derecho);
            //nuevo.add(izquierdo);
            return nuevo;
        }
    |   <EOF> {return null;}
}

Nodo T() :
{
Token t;
//String aux;
Nodo nuevo = null;
Nodo aux;
}
{
    t=<Cualquiera> {
        imprimir("Cual->"+t.image);//return t.image + " ";
        nuevo = new Nodo("cadena",t.image, t.beginColumn, t.beginLine);
        return nuevo;
    }



    | t=<numeral> aux = ET3() 
    {
        imprimir("#->"+t.image);//return aux + " ";
        if(aux.getTipo().equals("cadena"))
        {
            nuevo = aux;
            nuevo.setValue(aux.getTipo()+"#");
            return nuevo;
        }
        else    
        {
            nuevo = new Nodo();
        }   

    }
    | t=<punto> 
    {
         imprimir(".->"+t.image);//return "padre ";
         nuevo = new Nodo("var","this",t.beginColumn, t.beginLine);
         return nuevo;

    }
    | t=<doblepunto> 
    { 
        imprimir("..->"+t.image);//return "madre";
        nuevo = new Nodo("var","padre",t.beginColumn, t.beginLine);
        return nuevo;
    }
    | t=<funcion_vacia>
    {
        imprimir("funcion()->"+t.image);//
        nuevo = new Nodo("funcion",t.image,t.beginColumn, t.beginLine);
        return nuevo;
    }
}

Nodo ET3():
{
    String cad;
    String auxiliar;
    Token t= null;
    Nodo nuevo = null;
}

{
    <corchA> t=<Cualquiera> <corchC>
    {
        nuevo = new Nodo("variable",t.image, t.beginColumn, t.beginLine);        
        imprimir("Var->"+t.image);
        //return  "+ " + t.image +"+ ";
        return nuevo;
     
    }
    |t=<Cualquiera> 
    {                      
        nuevo = new Nodo("cadena",t.image, t.beginColumn,t.beginLine);        
        imprimir("Color->"+t.image);
        //return "#"+t.image +" ";
        return nuevo;
    }
}